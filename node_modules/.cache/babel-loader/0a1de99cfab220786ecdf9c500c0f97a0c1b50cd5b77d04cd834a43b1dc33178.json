{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getRouteRegex: null,\n  getNamedRouteRegex: null,\n  getNamedMiddlewareRegex: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getRouteRegex: function () {\n    return getRouteRegex;\n  },\n  getNamedRouteRegex: function () {\n    return getNamedRouteRegex;\n  },\n  getNamedMiddlewareRegex: function () {\n    return getNamedMiddlewareRegex;\n  }\n});\nconst _interceptionroutes = require(\"../../../../server/future/helpers/interception-routes\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */\nfunction parseParameter(param) {\n  const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith(\"...\");\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getParametrizedRoute(route) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n  const groups = {};\n  let groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(segment => {\n      const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n      const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n      ;\n      if (markerMatch && paramMatches) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n      } else if (paramMatches) {\n        const {\n          key,\n          repeat,\n          optional\n        } = parseParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(\"\"),\n    groups\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute);\n  return {\n    re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0;\n  return () => {\n    let routeKey = \"\";\n    let j = ++i;\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + (j - 1) % 26);\n      j = Math.floor((j - 1) / 26);\n    }\n    return routeKey;\n  };\n}\nfunction getSafeKeyFromSegment(param) {\n  let {\n    interceptionMarker,\n    getSafeRouteKey,\n    segment,\n    routeKeys,\n    keyPrefix\n  } = param;\n  const {\n    key,\n    optional,\n    repeat\n  } = parseParameter(segment);\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, \"\");\n  if (keyPrefix) {\n    cleanedKey = \"\" + keyPrefix + cleanedKey;\n  }\n  let invalidKey = false;\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true;\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true;\n  }\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey();\n  }\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n  } else {\n    routeKeys[cleanedKey] = key;\n  }\n  // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n  const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n  return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(segment => {\n      const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(m => segment.startsWith(m));\n      const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n      ;\n      if (hasInterceptionMarker && paramMatches) {\n        const [usedMarker] = segment.split(paramMatches[0]);\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          interceptionMarker: usedMarker,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n        });\n      } else if (paramMatches) {\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n        });\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(\"\"),\n    routeKeys\n  };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n  return {\n    ...getRouteRegex(normalizedRoute),\n    namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n    routeKeys: result.routeKeys\n  };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute);\n  const {\n    catchAll = true\n  } = options;\n  if (parameterizedRoute === \"/\") {\n    let catchAllRegex = catchAll ? \".*\" : \"\";\n    return {\n      namedRegex: \"^/\" + catchAllRegex + \"$\"\n    };\n  }\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute, false);\n  let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n  return {\n    namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","module","getRouteRegex","getNamedRouteRegex","getNamedMiddlewareRegex","_export","target","all","name","enumerable","get","_interceptionroutes","require","_escaperegexp","_removetrailingslash","NEXT_QUERY_PARAM_PREFIX","NEXT_INTERCEPTION_MARKER_PREFIX","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","markerMatch","INTERCEPTION_ROUTE_MARKERS","find","m","paramMatches","match","pos","escapeStringRegexp","join","normalizedRoute","re","RegExp","buildGetSafeRouteKey","i","routeKey","j","String","fromCharCode","Math","floor","getSafeKeyFromSegment","interceptionMarker","getSafeRouteKey","routeKeys","keyPrefix","cleanedKey","replace","invalidKey","length","isNaN","parseInt","interceptionPrefix","getNamedParametrizedRoute","prefixRouteKeys","namedParameterizedRoute","hasInterceptionMarker","some","usedMarker","undefined","prefixRouteKey","result","namedRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["C:/Users/User/Documents/GitHub/e-billing/node_modules/next/dist/shared/lib/router/utils/route-regex.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getRouteRegex: null,\n    getNamedRouteRegex: null,\n    getNamedMiddlewareRegex: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = require(\"../../../../server/future/helpers/interception-routes\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n}\n\n//# sourceMappingURL=route-regex.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}