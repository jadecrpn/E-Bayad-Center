{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getPathMatch\", {\n  enumerable: true,\n  get: function () {\n    return getPathMatch;\n  }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n  const keys = [];\n  const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {\n    delimiter: \"/\",\n    sensitive: typeof (options == null ? void 0 : options.sensitive) === \"boolean\" ? options.sensitive : false,\n    strict: options == null ? void 0 : options.strict\n  });\n  const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n  /**\n  * A matcher function that will check if a given pathname matches the path\n  * given in the builder function. When the path does not match it will return\n  * `false` but if it does it will return an object with the matched params\n  * merged with the params provided in the second argument.\n  */\n  return (pathname, params) => {\n    // If no pathname is provided it's not a match.\n    if (typeof pathname !== \"string\") return false;\n    const match = matcher(pathname);\n    // If the path did not match `false` will be returned.\n    if (!match) return false;\n    /**\n    * If unnamed params are not allowed they must be removed from\n    * the matched parameters. path-to-regexp uses \"string\" for named and\n    * \"number\" for unnamed parameters.\n    */\n    if (options == null ? void 0 : options.removeUnnamedParams) {\n      for (const key of keys) {\n        if (typeof key.name === \"number\") {\n          delete match.params[key.name];\n        }\n      }\n    }\n    return {\n      ...params,\n      ...match.params\n    };\n  };\n}","map":{"version":3,"names":["getPathMatch","path","options","keys","regexp","_pathtoregexp","pathToRegexp","delimiter","sensitive","strict","matcher","regexpToFunction","regexModifier","RegExp","source","flags","pathname","params","match","removeUnnamedParams","key","name"],"sources":["../../../../../src/shared/lib/router/utils/path-match.ts"],"sourcesContent":[null],"mappings":";;;;;+BAqCgB;;;WAAAA,YAAA;;;8BApCa;AAoCtB,SAASA,aAAaC,IAAY,EAAEC,OAAiB;EAC1D,MAAMC,IAAA,GAAc,EAAE;EACtB,MAAMC,MAAA,GAAS,IAAAC,aAAA,CAAAC,YAAY,EAACL,IAAA,EAAME,IAAA,EAAM;IACtCI,SAAA,EAAW;IACXC,SAAA,EACE,QAAON,OAAA,oBAAAA,OAAA,CAASM,SAAS,MAAK,YAAYN,OAAA,CAAQM,SAAS,GAAG;IAChEC,MAAM,EAAEP,OAAA,oBAAAA,OAAA,CAASO;EACnB;EAEA,MAAMC,OAAA,GAAU,IAAAL,aAAA,CAAAM,gBAAgB,EAC9B,CAAAT,OAAA,oBAAAA,OAAA,CAASU,aAAa,IAClB,IAAIC,MAAA,CAAOX,OAAA,CAAQU,aAAa,CAACR,MAAA,CAAOU,MAAM,GAAGV,MAAA,CAAOW,KAAK,IAC7DX,MAAA,EACJD,IAAA;EAGF;;;;;;EAMA,OAAO,CAACa,QAAA,EAAUC,MAAA;IAChB;IACA,IAAI,OAAOD,QAAA,KAAa,UAAU,OAAO;IAEzC,MAAME,KAAA,GAAQR,OAAA,CAAQM,QAAA;IAEtB;IACA,IAAI,CAACE,KAAA,EAAO,OAAO;IAEnB;;;;;IAKA,IAAIhB,OAAA,oBAAAA,OAAA,CAASiB,mBAAmB,EAAE;MAChC,KAAK,MAAMC,GAAA,IAAOjB,IAAA,EAAM;QACtB,IAAI,OAAOiB,GAAA,CAAIC,IAAI,KAAK,UAAU;UAChC,OAAOH,KAAA,CAAMD,MAAM,CAACG,GAAA,CAAIC,IAAI,CAAC;QAC/B;MACF;IACF;IAEA,OAAO;MAAE,GAAGJ,MAAM;MAAE,GAAGC,KAAA,CAAMD;IAAO;EACtC;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}