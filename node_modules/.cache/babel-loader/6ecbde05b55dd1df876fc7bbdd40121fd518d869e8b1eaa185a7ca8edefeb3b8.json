{"ast":null,"code":"// minimal implementation MurmurHash2 hash function\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"BloomFilter\", {\n  enumerable: true,\n  get: function () {\n    return BloomFilter;\n  }\n});\nfunction murmurhash2(str) {\n  let h = 0;\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charCodeAt(i);\n    h = Math.imul(h ^ c, 0x5bd1e995);\n    h ^= h >>> 13;\n    h = Math.imul(h, 0x5bd1e995);\n  }\n  return h >>> 0;\n}\n// default to 0.01% error rate as the filter compresses very well\nconst DEFAULT_ERROR_RATE = 0.0001;\nclass BloomFilter {\n  static from(items, errorRate) {\n    if (errorRate === void 0) errorRate = DEFAULT_ERROR_RATE;\n    const filter = new BloomFilter(items.length, errorRate);\n    for (const item of items) {\n      filter.add(item);\n    }\n    return filter;\n  }\n  export() {\n    const data = {\n      numItems: this.numItems,\n      errorRate: this.errorRate,\n      numBits: this.numBits,\n      numHashes: this.numHashes,\n      bitArray: this.bitArray\n    };\n    if (process.env.NEXT_RUNTIME === \"nodejs\") {\n      if (this.errorRate < DEFAULT_ERROR_RATE) {\n        const filterData = JSON.stringify(data);\n        const gzipSize = require(\"next/dist/compiled/gzip-size\").sync(filterData);\n        if (gzipSize > 1024) {\n          console.warn(\"Creating filter with error rate less than 0.1% (0.001) can increase the size dramatically proceed with caution. Received error rate \" + this.errorRate + \" resulted in size \" + filterData.length + \" bytes, \" + gzipSize + \" bytes (gzip)\");\n        }\n      }\n    }\n    return data;\n  }\n  import(data) {\n    this.numItems = data.numItems;\n    this.errorRate = data.errorRate;\n    this.numBits = data.numBits;\n    this.numHashes = data.numHashes;\n    this.bitArray = data.bitArray;\n  }\n  add(item) {\n    const hashValues = this.getHashValues(item);\n    hashValues.forEach(hash => {\n      this.bitArray[hash] = 1;\n    });\n  }\n  contains(item) {\n    const hashValues = this.getHashValues(item);\n    return hashValues.every(hash => this.bitArray[hash]);\n  }\n  getHashValues(item) {\n    const hashValues = [];\n    for (let i = 1; i <= this.numHashes; i++) {\n      const hash = murmurhash2(\"\" + item + i) % this.numBits;\n      hashValues.push(hash);\n    }\n    return hashValues;\n  }\n  constructor(numItems, errorRate = DEFAULT_ERROR_RATE) {\n    this.numItems = numItems;\n    this.errorRate = errorRate;\n    this.numBits = Math.ceil(-(numItems * Math.log(errorRate)) / (Math.log(2) * Math.log(2)));\n    this.numHashes = Math.ceil(this.numBits / numItems * Math.log(2));\n    this.bitArray = new Array(this.numBits).fill(0);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","BloomFilter","murmurhash2","str","h","i","length","c","charCodeAt","Math","imul","DEFAULT_ERROR_RATE","from","items","errorRate","filter","item","add","export","data","numItems","numBits","numHashes","bitArray","process","env","NEXT_RUNTIME","filterData","JSON","stringify","gzipSize","require","sync","console","warn","import","hashValues","getHashValues","forEach","hash","contains","every","push","constructor","ceil","log","Array","fill"],"sources":["C:/Users/User/Documents/GitHub/e-billing/node_modules/next/dist/shared/lib/bloom-filter.js"],"sourcesContent":["// minimal implementation MurmurHash2 hash function\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"BloomFilter\", {\n    enumerable: true,\n    get: function() {\n        return BloomFilter;\n    }\n});\nfunction murmurhash2(str) {\n    let h = 0;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        h = Math.imul(h ^ c, 0x5bd1e995);\n        h ^= h >>> 13;\n        h = Math.imul(h, 0x5bd1e995);\n    }\n    return h >>> 0;\n}\n// default to 0.01% error rate as the filter compresses very well\nconst DEFAULT_ERROR_RATE = 0.0001;\nclass BloomFilter {\n    static from(items, errorRate) {\n        if (errorRate === void 0) errorRate = DEFAULT_ERROR_RATE;\n        const filter = new BloomFilter(items.length, errorRate);\n        for (const item of items){\n            filter.add(item);\n        }\n        return filter;\n    }\n    export() {\n        const data = {\n            numItems: this.numItems,\n            errorRate: this.errorRate,\n            numBits: this.numBits,\n            numHashes: this.numHashes,\n            bitArray: this.bitArray\n        };\n        if (process.env.NEXT_RUNTIME === \"nodejs\") {\n            if (this.errorRate < DEFAULT_ERROR_RATE) {\n                const filterData = JSON.stringify(data);\n                const gzipSize = require(\"next/dist/compiled/gzip-size\").sync(filterData);\n                if (gzipSize > 1024) {\n                    console.warn(\"Creating filter with error rate less than 0.1% (0.001) can increase the size dramatically proceed with caution. Received error rate \" + this.errorRate + \" resulted in size \" + filterData.length + \" bytes, \" + gzipSize + \" bytes (gzip)\");\n                }\n            }\n        }\n        return data;\n    }\n    import(data) {\n        this.numItems = data.numItems;\n        this.errorRate = data.errorRate;\n        this.numBits = data.numBits;\n        this.numHashes = data.numHashes;\n        this.bitArray = data.bitArray;\n    }\n    add(item) {\n        const hashValues = this.getHashValues(item);\n        hashValues.forEach((hash)=>{\n            this.bitArray[hash] = 1;\n        });\n    }\n    contains(item) {\n        const hashValues = this.getHashValues(item);\n        return hashValues.every((hash)=>this.bitArray[hash]);\n    }\n    getHashValues(item) {\n        const hashValues = [];\n        for(let i = 1; i <= this.numHashes; i++){\n            const hash = murmurhash2(\"\" + item + i) % this.numBits;\n            hashValues.push(hash);\n        }\n        return hashValues;\n    }\n    constructor(numItems, errorRate = DEFAULT_ERROR_RATE){\n        this.numItems = numItems;\n        this.errorRate = errorRate;\n        this.numBits = Math.ceil(-(numItems * Math.log(errorRate)) / (Math.log(2) * Math.log(2)));\n        this.numHashes = Math.ceil(this.numBits / numItems * Math.log(2));\n        this.bitArray = new Array(this.numBits).fill(0);\n    }\n}\n\n//# sourceMappingURL=bloom-filter.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}