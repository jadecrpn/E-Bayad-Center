{"ast":null,"code":"// tslint:disable:no-console\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  default: null,\n  matchesMiddleware: null,\n  createKey: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  default: function () {\n    return Router;\n  },\n  matchesMiddleware: function () {\n    return matchesMiddleware;\n  },\n  createKey: function () {\n    return createKey;\n  }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _removetrailingslash = require(\"./utils/remove-trailing-slash\");\nconst _routeloader = require(\"../../../client/route-loader\");\nconst _script = require(\"../../../client/script\");\nconst _iserror = /*#__PURE__*/_interop_require_wildcard._(require(\"../../../lib/is-error\"));\nconst _denormalizepagepath = require(\"../page-path/denormalize-page-path\");\nconst _normalizelocalepath = require(\"../i18n/normalize-locale-path\");\nconst _mitt = /*#__PURE__*/_interop_require_default._(require(\"../mitt\"));\nconst _utils = require(\"../utils\");\nconst _isdynamic = require(\"./utils/is-dynamic\");\nconst _parserelativeurl = require(\"./utils/parse-relative-url\");\nconst _resolverewrites = /*#__PURE__*/_interop_require_default._(require(\"./utils/resolve-rewrites\"));\nconst _routematcher = require(\"./utils/route-matcher\");\nconst _routeregex = require(\"./utils/route-regex\");\nconst _formaturl = require(\"./utils/format-url\");\nconst _detectdomainlocale = require(\"../../../client/detect-domain-locale\");\nconst _parsepath = require(\"./utils/parse-path\");\nconst _addlocale = require(\"../../../client/add-locale\");\nconst _removelocale = require(\"../../../client/remove-locale\");\nconst _removebasepath = require(\"../../../client/remove-base-path\");\nconst _addbasepath = require(\"../../../client/add-base-path\");\nconst _hasbasepath = require(\"../../../client/has-base-path\");\nconst _resolvehref = require(\"../../../client/resolve-href\");\nconst _isapiroute = require(\"../../../lib/is-api-route\");\nconst _getnextpathnameinfo = require(\"./utils/get-next-pathname-info\");\nconst _formatnextpathnameinfo = require(\"./utils/format-next-pathname-info\");\nconst _comparestates = require(\"./utils/compare-states\");\nconst _islocalurl = require(\"./utils/is-local-url\");\nconst _isbot = require(\"./utils/is-bot\");\nconst _omit = require(\"./utils/omit\");\nconst _interpolateas = require(\"./utils/interpolate-as\");\nconst _handlesmoothscroll = require(\"./utils/handle-smooth-scroll\");\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\nasync function matchesMiddleware(options) {\n  const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n  if (!matchers) return false;\n  const {\n    pathname: asPathname\n  } = (0, _parsepath.parsePath)(options.asPath);\n  // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n  const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n  const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n  // Check only path match on client. Matching \"has\" should be done on server\n  // where we can access more info such as headers, HttpOnly cookie, etc.\n  return matchers.some(m => new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n  const origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n  const origin = (0, _utils.getLocationOrigin)();\n  const hrefWasAbsolute = resolvedHref.startsWith(origin);\n  const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  }\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n  const nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n  };\n  const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  const matchedPath = response.headers.get(\"x-matched-path\");\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {\n      const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig,\n        parseData: true\n      });\n      let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(param => {\n        let [pages, {\n          __rewrites: rewrites\n        }] = param;\n        let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig: process.env.__NEXT_HAS_REWRITES ? undefined : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n        if (process.env.__NEXT_HAS_REWRITES) {\n          const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, path => resolveDynamicRoute(path, pages), options.router.locales);\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname;\n            as = parsedRewriteTarget.pathname;\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n          }\n        } else if (!pages.includes(fsPathname)) {\n          const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n        const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref\n        };\n      });\n    }\n    const src = (0, _parsepath.parsePath)(source);\n    const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n      ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n        nextConfig,\n        parseData: true\n      }),\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    });\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n  const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      const src = (0, _parsepath.parsePath)(redirectTarget);\n      const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n        ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n          nextConfig,\n          parseData: true\n        }),\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      });\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + pathname + src.query + src.hash,\n        newUrl: \"\" + pathname + src.query + src.hash\n      });\n    }\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\nasync function withMiddlewareEffects(options) {\n  const matches = await matchesMiddleware(options);\n  if (!matches || !options.fetchData) {\n    return null;\n  }\n  try {\n    const data = await options.fetchData();\n    const effect = await getMiddlewareData(data.dataHref, data.response, options);\n    return {\n      dataHref: data.dataHref,\n      json: data.json,\n      response: data.response,\n      text: data.text,\n      cacheKey: data.cacheKey,\n      effect\n    };\n  } catch (e) {\n    /**\n    * TODO: Revisit this in the future.\n    * For now we will not consider middleware data errors to be fatal.\n    * maybe we should revisit in the future.\n    */\n    return null;\n  }\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== \"undefined\" && \"scrollRestoration\" in window.history && !!function () {\n  try {\n    let v = \"__next\";\n    // eslint-disable-next-line no-sequences\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(response => {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\nfunction fetchNextData(param) {\n  let {\n    dataHref,\n    inflightCache,\n    isPrefetch,\n    hasMiddleware,\n    isServerRender,\n    parseJSON,\n    persistCache,\n    isBackground,\n    unstable_skipClientCache\n  } = param;\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n  var _params_method;\n  const getData = params => fetchRetry(dataHref, isServerRender ? 3 : 1, {\n    headers: Object.assign({}, isPrefetch ? {\n      purpose: \"prefetch\"\n    } : {}, isPrefetch && hasMiddleware ? {\n      \"x-middleware-prefetch\": \"1\"\n    } : {}),\n    method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n  }).then(response => {\n    if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n      return {\n        dataHref,\n        response,\n        text: \"\",\n        json: {},\n        cacheKey\n      };\n    }\n    return response.text().then(text => {\n      if (!response.ok) {\n        /**\n        * When the data response is a redirect because of a middleware\n        * we do not consider it an error. The headers must bring the\n        * mapped location.\n        * TODO: Change the status code in the handler.\n        */\n        if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n          return {\n            dataHref,\n            response,\n            text,\n            json: {},\n            cacheKey\n          };\n        }\n        if (response.status === 404) {\n          var _tryToParseAsJSON;\n          if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n            return {\n              dataHref,\n              json: {\n                notFound: SSG_DATA_NOT_FOUND\n              },\n              response,\n              text,\n              cacheKey\n            };\n          }\n        }\n        const error = new Error(\"Failed to load static props\");\n        /**\n        * We should only trigger a server-side transition if this was\n        * caused on a client-side transition. Otherwise, we'd get into\n        * an infinite loop.\n        */\n        if (!isServerRender) {\n          (0, _routeloader.markAssetError)(error);\n        }\n        throw error;\n      }\n      return {\n        dataHref,\n        json: parseJSON ? tryToParseAsJSON(text) : null,\n        response,\n        text,\n        cacheKey\n      };\n    });\n  }).then(data => {\n    if (!persistCache || process.env.NODE_ENV !== \"production\" || data.response.headers.get(\"x-middleware-cache\") === \"no-cache\") {\n      delete inflightCache[cacheKey];\n    }\n    return data;\n  }).catch(err => {\n    if (!unstable_skipClientCache) {\n      delete inflightCache[cacheKey];\n    }\n    if (\n    // chrome\n    err.message === \"Failed to fetch\" ||\n    // firefox\n    err.message === \"NetworkError when attempting to fetch resource.\" ||\n    // safari\n    err.message === \"Load failed\") {\n      (0, _routeloader.markAssetError)(err);\n    }\n    throw err;\n  });\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(data => {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\nfunction createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n  let {\n    url,\n    router\n  } = param;\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n  window.location.href = url;\n}\nconst getCancelledHandler = param => {\n  let {\n    route,\n    router\n  } = param;\n  let cancelled = false;\n  const cancel = router.clc = () => {\n    cancelled = true;\n  };\n  const handleCancelled = () => {\n    if (cancelled) {\n      const error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n  return handleCancelled;\n};\nclass Router {\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n  back() {\n    window.history.back();\n  }\n  /**\n  * Go forward in history\n  */\n  forward() {\n    window.history.forward();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  push(url, as, options) {\n    if (options === void 0) options = {};\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch (e) {}\n      }\n    }\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change(\"pushState\", url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  replace(url, as, options) {\n    if (options === void 0) options = {};\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change(\"replaceState\", url, as, options);\n  }\n  async _bfl(as, resolvedAs, locale, skipNavigate) {\n    if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n      let matchesBflStatic = false;\n      let matchesBflDynamic = false;\n      for (const curAs of [as, resolvedAs]) {\n        if (curAs) {\n          const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n          const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n          if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname)) {\n            var _this__bfl_s, _this__bfl_s1;\n            matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n            for (const normalizedAS of [asNoSlash, asNoSlashLocale]) {\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              const curAsParts = normalizedAS.split(\"/\");\n              for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {\n                var _this__bfl_d;\n                const currentPart = curAsParts.slice(0, i).join(\"/\");\n                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                  matchesBflDynamic = true;\n                  break;\n                }\n              }\n            }\n            // if the client router filter is matched then we trigger\n            // a hard navigation\n            if (matchesBflStatic || matchesBflDynamic) {\n              if (skipNavigate) {\n                return true;\n              }\n              handleHardNavigation({\n                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                router: this\n              });\n              return new Promise(() => {});\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n  async change(method, url, as, options, forcedScroll) {\n    var _this_components_pathname;\n    if (!(0, _islocalurl.isLocalURL)(url)) {\n      handleHardNavigation({\n        url,\n        router: this\n      });\n      return false;\n    }\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n    const isQueryUpdating = options._h === 1;\n    if (!isQueryUpdating && !options.shallow) {\n      await this._bfl(as, undefined, options.locale);\n    }\n    let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n    const nextState = {\n      ...this.state\n    };\n    // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n    // or a navigation has occurred\n    const readyStateChange = this.isReady !== true;\n    this.isReady = true;\n    const isSsr = this.isSsr;\n    if (!isQueryUpdating) {\n      this.isSsr = false;\n    }\n    // if a route transition is already in progress before\n    // the query updating is triggered ignore query updating\n    if (isQueryUpdating && this.clc) {\n      return false;\n    }\n    const prevLocale = nextState.locale;\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n      if (typeof options.locale === \"undefined\") {\n        options.locale = nextState.locale;\n      }\n      const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n      const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n      if (localePathResult.detectedLocale) {\n        nextState.locale = localePathResult.detectedLocale;\n        parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n        as = (0, _formaturl.formatWithValidation)(parsedAs);\n        url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n      }\n      let didNavigate = false;\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        var _this_locales;\n        // if the locale isn't configured hard navigate to show 404 page\n        if (!((_this_locales = this.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {\n          parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);\n          handleHardNavigation({\n            url: (0, _formaturl.formatWithValidation)(parsedAs),\n            router: this\n          });\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true;\n        }\n      }\n      const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale);\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n          const asNoBasePath = (0, _removebasepath.removeBasePath)(as);\n          handleHardNavigation({\n            url: \"http\" + (detectedDomain.http ? \"\" : \"s\") + \"://\" + detectedDomain.domain + (0, _addbasepath.addBasePath)(\"\" + (nextState.locale === detectedDomain.defaultLocale ? \"\" : \"/\" + nextState.locale) + (asNoBasePath === \"/\" ? \"\" : asNoBasePath) || \"/\"),\n            router: this\n          });\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true;\n        }\n      }\n      if (didNavigate) {\n        return new Promise(() => {});\n      }\n    }\n    // marking route changes as a navigation start entry\n    if (_utils.ST) {\n      performance.mark(\"routeChange\");\n    }\n    const {\n      shallow = false,\n      scroll = true\n    } = options;\n    const routeProps = {\n      shallow\n    };\n    if (this._inFlightRoute && this.clc) {\n      if (!isSsr) {\n        Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n      }\n      this.clc();\n      this.clc = null;\n    }\n    as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n    this._inFlightRoute = as;\n    const localeChange = prevLocale !== nextState.locale;\n    // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs;\n      Router.events.emit(\"hashChangeStart\", as, routeProps);\n      // TODO: do we need the resolved href when only a hash change?\n      this.changeState(method, url, as, {\n        ...options,\n        scroll: false\n      });\n      if (scroll) {\n        this.scrollToHash(cleanedAs);\n      }\n      try {\n        await this.set(nextState, this.components[nextState.route], null);\n      } catch (err) {\n        if ((0, _iserror.default)(err) && err.cancelled) {\n          Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n        }\n        throw err;\n      }\n      Router.events.emit(\"hashChangeComplete\", as, routeProps);\n      return true;\n    }\n    let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n    // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n    let pages, rewrites;\n    try {\n      [pages, {\n        __rewrites: rewrites\n      }] = await Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return false;\n    }\n    // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = \"replaceState\";\n    }\n    // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n    let resolvedAs = as;\n    // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n    pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n    let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    const parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n    // if we detected the path as app route during prefetching\n    // trigger hard navigation\n    if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return new Promise(() => {});\n    }\n    const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n    // we don't attempt resolve asPath when we need to execute\n    // middleware as the resolving will occur server-side\n    const isMiddlewareMatch = !options.shallow && (await matchesMiddleware({\n      asPath: as,\n      locale: nextState.locale,\n      router: this\n    }));\n    if (isQueryUpdating && isMiddlewareMatch) {\n      shouldResolveHref = false;\n    }\n    if (shouldResolveHref && pathname !== \"/_error\") {\n      options._shouldResolveHref = true;\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith(\"/\")) {\n        const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, p => resolveDynamicRoute(p, pages), this.locales);\n        if (rewritesResult.externalDest) {\n          handleHardNavigation({\n            url: as,\n            router: this\n          });\n          return true;\n        }\n        if (!isMiddlewareMatch) {\n          resolvedAs = rewritesResult.asPath;\n        }\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n          if (!isMiddlewareMatch) {\n            url = (0, _formaturl.formatWithValidation)(parsed);\n          }\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n          if (!isMiddlewareMatch) {\n            url = (0, _formaturl.formatWithValidation)(parsed);\n          }\n        }\n      }\n    }\n    if (!(0, _islocalurl.isLocalURL)(as)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n      }\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return false;\n    }\n    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n    route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    let routeMatch = false;\n    if ((0, _isdynamic.isDynamicRoute)(route)) {\n      const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeregex.getRouteRegex)(route);\n      routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param] && !routeRegex.groups[param].optional);\n        if (missingParams.length > 0 && !isMiddlewareMatch) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n          }\n          throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: (0, _omit.omit)(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n    if (!isQueryUpdating) {\n      Router.events.emit(\"routeChangeStart\", as, routeProps);\n    }\n    const isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n    try {\n      var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n      let routeInfo = await this.getRouteInfo({\n        route,\n        pathname,\n        query,\n        as,\n        resolvedAs,\n        routeProps,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview,\n        hasMiddleware: isMiddlewareMatch,\n        unstable_skipClientCache: options.unstable_skipClientCache,\n        isQueryUpdating: isQueryUpdating && !this.isFallback,\n        isMiddlewareRewrite\n      });\n      if (!isQueryUpdating && !options.shallow) {\n        await this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n      }\n      if (\"route\" in routeInfo && isMiddlewareMatch) {\n        pathname = routeInfo.route || route;\n        route = pathname;\n        if (!routeProps.shallow) {\n          query = Object.assign({}, routeInfo.query || {}, query);\n        }\n        const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n        if (routeMatch && pathname !== cleanedParsedPathname) {\n          Object.keys(routeMatch).forEach(key => {\n            if (routeMatch && query[key] === routeMatch[key]) {\n              delete query[key];\n            }\n          });\n        }\n        if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n          const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n          let rewriteAs = prefixedAs;\n          if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n          }\n          if (process.env.__NEXT_I18N_SUPPORT) {\n            const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, this.locales);\n            nextState.locale = localeResult.detectedLocale || nextState.locale;\n            rewriteAs = localeResult.pathname;\n          }\n          const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n          const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n          if (curRouteMatch) {\n            Object.assign(query, curRouteMatch);\n          }\n        }\n      }\n      // If the routeInfo brings a redirect we simply apply it.\n      if (\"type\" in routeInfo) {\n        if (routeInfo.type === \"redirect-internal\") {\n          return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n        } else {\n          handleHardNavigation({\n            url: routeInfo.destination,\n            router: this\n          });\n          return new Promise(() => {});\n        }\n      }\n      const component = routeInfo.Component;\n      if (component && component.unstable_scriptLoader) {\n        const scripts = [].concat(component.unstable_scriptLoader());\n        scripts.forEach(script => {\n          (0, _script.handleClientScriptLoad)(script.props);\n        });\n      }\n      // handle redirect on client-transition\n      if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n        if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n          // Use the destination from redirect without adding locale\n          options.locale = false;\n          const destination = routeInfo.props.pageProps.__N_REDIRECT;\n          // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n          if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n            const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n            const {\n              url: newUrl,\n              as: newAs\n            } = prepareUrlAs(this, destination, destination);\n            return this.change(method, newUrl, newAs, options);\n          }\n          handleHardNavigation({\n            url: destination,\n            router: this\n          });\n          return new Promise(() => {});\n        }\n        nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n        // handle SSG data 404\n        if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n          try {\n            await this.fetchComponent(\"/404\");\n            notFoundRoute = \"/404\";\n          } catch (_) {\n            notFoundRoute = \"/_error\";\n          }\n          routeInfo = await this.getRouteInfo({\n            route: notFoundRoute,\n            pathname: notFoundRoute,\n            query,\n            as,\n            resolvedAs,\n            routeProps: {\n              shallow: false\n            },\n            locale: nextState.locale,\n            isPreview: nextState.isPreview,\n            isNotFound: true\n          });\n          if (\"type\" in routeInfo) {\n            throw new Error(\"Unexpected middleware effect on /404\");\n          }\n        }\n      }\n      if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        routeInfo.props.pageProps.statusCode = 500;\n      }\n      var _routeInfo_route;\n      // shallow routing is only allowed for same page URL changes.\n      const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n      var _options_scroll;\n      const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n      const resetScroll = shouldScroll ? {\n        x: 0,\n        y: 0\n      } : null;\n      const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n      // the new state that the router gonna set\n      const upcomingRouterState = {\n        ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false\n      };\n      // When the page being rendered is the 404 page, we should only update the\n      // query parameters. Route changes here might add the basePath when it\n      // wasn't originally present. This is also why this block is before the\n      // below `changeState` call which updates the browser's history (changing\n      // the URL).\n      if (isQueryUpdating && isErrorRoute) {\n        var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n        routeInfo = await this.getRouteInfo({\n          route: this.pathname,\n          pathname: this.pathname,\n          query,\n          as,\n          resolvedAs,\n          routeProps: {\n            shallow: false\n          },\n          locale: nextState.locale,\n          isPreview: nextState.isPreview,\n          isQueryUpdating: isQueryUpdating && !this.isFallback\n        });\n        if (\"type\" in routeInfo) {\n          throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n        }\n        if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n          // ensure statusCode is still correct for static 500 page\n          // when updating query information\n          routeInfo.props.pageProps.statusCode = 500;\n        }\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n        } catch (err) {\n          if ((0, _iserror.default)(err) && err.cancelled) {\n            Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n          }\n          throw err;\n        }\n        return true;\n      }\n      Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n      this.changeState(method, url, as, options);\n      // for query updates we can skip it if the state is unchanged and we don't\n      // need to scroll\n      // https://github.com/vercel/next.js/issues/37139\n      const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n      if (!canSkipUpdating) {\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n        } catch (e) {\n          if (e.cancelled) routeInfo.error = routeInfo.error || e;else throw e;\n        }\n        if (routeInfo.error) {\n          if (!isQueryUpdating) {\n            Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n          }\n          throw routeInfo.error;\n        }\n        if (process.env.__NEXT_I18N_SUPPORT) {\n          if (nextState.locale) {\n            document.documentElement.lang = nextState.locale;\n          }\n        }\n        if (!isQueryUpdating) {\n          Router.events.emit(\"routeChangeComplete\", as, routeProps);\n        }\n        // A hash mark # is the optional last part of a URL\n        const hashRegex = /#.+$/;\n        if (shouldScroll && hashRegex.test(as)) {\n          this.scrollToHash(as);\n        }\n      }\n      return true;\n    } catch (err) {\n      if ((0, _iserror.default)(err) && err.cancelled) {\n        return false;\n      }\n      throw err;\n    }\n  }\n  changeState(method, url, as, options) {\n    if (options === void 0) options = {};\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof window.history === \"undefined\") {\n        console.error(\"Warning: window.history is not available.\");\n        return;\n      }\n      if (typeof window.history[method] === \"undefined\") {\n        console.error(\"Warning: window.history.\" + method + \" is not available\");\n        return;\n      }\n    }\n    if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        key: this._key = method !== \"pushState\" ? this._key : createKey()\n      },\n      // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/docs/Web/API/History/replaceState\n      \"\", as);\n    }\n  }\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    console.error(err);\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n    if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n      Router.events.emit(\"routeChangeError\", err, as, routeProps);\n      // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n      throw buildCancellationError();\n    }\n    try {\n      let props;\n      const {\n        page: Component,\n        styleSheets\n      } = await this.fetchComponent(\"/_error\");\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error(\"Error in error page `getInitialProps`: \", gipErr);\n          routeInfo.props = {};\n        }\n      }\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n    }\n  }\n  async getRouteInfo(param) {\n    let {\n      route: requestedRoute,\n      pathname,\n      query,\n      as,\n      resolvedAs,\n      routeProps,\n      locale,\n      hasMiddleware,\n      isPreview,\n      unstable_skipClientCache,\n      isQueryUpdating,\n      isMiddlewareRewrite,\n      isNotFound\n    } = param;\n    /**\n    * This `route` binding can change if there's a rewrite\n    * so we keep a reference to the original requested route\n    * so we can store the cache for it and avoid re-requesting every time\n    * for shallow routing purposes.\n    */\n    let route = requestedRoute;\n    try {\n      var _data_effect, _data_effect1, _data_effect2, _data_response;\n      const handleCancelled = getCancelledHandler({\n        route,\n        router: this\n      });\n      let existingInfo = this.components[route];\n      if (routeProps.shallow && existingInfo && this.route === route) {\n        return existingInfo;\n      }\n      if (hasMiddleware) {\n        existingInfo = undefined;\n      }\n      let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && process.env.NODE_ENV !== \"development\" ? existingInfo : undefined;\n      const isBackground = isQueryUpdating;\n      const fetchNextDataParams = {\n        dataHref: this.pageLoader.getDataHref({\n          href: (0, _formaturl.formatWithValidation)({\n            pathname,\n            query\n          }),\n          skipInterpolation: true,\n          asPath: isNotFound ? \"/404\" : resolvedAs,\n          locale\n        }),\n        hasMiddleware: true,\n        isServerRender: this.isSsr,\n        parseJSON: true,\n        inflightCache: isBackground ? this.sbc : this.sdc,\n        persistCache: !isPreview,\n        isPrefetch: false,\n        unstable_skipClientCache,\n        isBackground\n      };\n      let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n        fetchData: () => fetchNextData(fetchNextDataParams),\n        asPath: isNotFound ? \"/404\" : resolvedAs,\n        locale: locale,\n        router: this\n      }).catch(err => {\n        // we don't hard error during query updating\n        // as it's un-necessary and doesn't need to be fatal\n        // unless it is a fallback route and the props can't\n        // be loaded\n        if (isQueryUpdating) {\n          return null;\n        }\n        throw err;\n      });\n      // when rendering error routes we don't apply middleware\n      // effects\n      if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n        data.effect = undefined;\n      }\n      if (isQueryUpdating) {\n        if (!data) {\n          data = {\n            json: self.__NEXT_DATA__.props\n          };\n        } else {\n          data.json = self.__NEXT_DATA__.props;\n        }\n      }\n      handleCancelled();\n      if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n        return data.effect;\n      }\n      if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\") {\n        const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n        const pages = await this.pageLoader.getPageList();\n        // during query updating the page must match although during\n        // client-transition a redirect that doesn't match a page\n        // can be returned and this should trigger a hard navigation\n        // which is valid for incremental migration\n        if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n          route = resolvedRoute;\n          pathname = data.effect.resolvedHref;\n          query = {\n            ...query,\n            ...data.effect.parsedAs.query\n          };\n          resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n          // Check again the cache with the new destination.\n          existingInfo = this.components[route];\n          if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n            // If we have a match with the current route due to rewrite,\n            // we can copy the existing information to the rewritten one.\n            // Then, we return the information along with the matched route.\n            return {\n              ...existingInfo,\n              route\n            };\n          }\n        }\n      }\n      if ((0, _isapiroute.isAPIRoute)(route)) {\n        handleHardNavigation({\n          url: as,\n          router: this\n        });\n        return new Promise(() => {});\n      }\n      const routeInfo = cachedRouteInfo || (await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP\n      })));\n      if (process.env.NODE_ENV !== \"production\") {\n        const {\n          isValidElementType\n        } = require(\"next/dist/compiled/react-is\");\n        if (!isValidElementType(routeInfo.Component)) {\n          throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n        }\n      }\n      const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n      const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n      // For non-SSG prefetches that bailed before sending data\n      // we clear the cache to fetch full response\n      if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n        delete this.sdc[data.dataHref];\n      }\n      const {\n        props,\n        cacheKey\n      } = await this._getData(async () => {\n        if (shouldFetchData) {\n          if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n            return {\n              cacheKey: data.cacheKey,\n              props: data.json\n            };\n          }\n          const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n            href: (0, _formaturl.formatWithValidation)({\n              pathname,\n              query\n            }),\n            asPath: resolvedAs,\n            locale\n          });\n          const fetched = await fetchNextData({\n            dataHref,\n            isServerRender: this.isSsr,\n            parseJSON: true,\n            inflightCache: wasBailedPrefetch ? {} : this.sdc,\n            persistCache: !isPreview,\n            isPrefetch: false,\n            unstable_skipClientCache\n          });\n          return {\n            cacheKey: fetched.cacheKey,\n            props: fetched.json || {}\n          };\n        }\n        return {\n          headers: {},\n          props: await this.getInitialProps(routeInfo.Component,\n          // we provide AppTree later so this needs to be `any`\n          {\n            pathname,\n            query,\n            asPath: as,\n            locale,\n            locales: this.locales,\n            defaultLocale: this.defaultLocale\n          })\n        };\n      });\n      // Only bust the data cache for SSP routes although\n      // middleware can skip cache per request with\n      // x-middleware-cache: no-cache as well\n      if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n        delete this.sdc[cacheKey];\n      }\n      // we kick off a HEAD request in the background\n      // when a non-prefetch request is made to signal revalidation\n      if (!this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== \"development\" && !isQueryUpdating) {\n        fetchNextData(Object.assign({}, fetchNextDataParams, {\n          isBackground: true,\n          persistCache: false,\n          inflightCache: this.sbc\n        })).catch(() => {});\n      }\n      props.pageProps = Object.assign({}, props.pageProps);\n      routeInfo.props = props;\n      routeInfo.route = route;\n      routeInfo.query = query;\n      routeInfo.resolvedAs = resolvedAs;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n    }\n  }\n  set(state, data, resetScroll) {\n    this.state = state;\n    return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\", 2);\n    const [newUrlNoHash, newHash] = as.split(\"#\", 2);\n    // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    }\n    // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    }\n    // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash;\n  }\n  scrollToHash(as) {\n    const [, hash = \"\"] = as.split(\"#\", 2);\n    (0, _handlesmoothscroll.handleSmoothScroll)(() => {\n      // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n      if (hash === \"\" || hash === \"top\") {\n        window.scrollTo(0, 0);\n        return;\n      }\n      // Decode hash to make non-latin anchor works.\n      const rawHash = decodeURIComponent(hash);\n      // First we check if the element by id is found\n      const idEl = document.getElementById(rawHash);\n      if (idEl) {\n        idEl.scrollIntoView();\n        return;\n      }\n      // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n      const nameEl = document.getElementsByName(rawHash)[0];\n      if (nameEl) {\n        nameEl.scrollIntoView();\n      }\n    }, {\n      onlyHashChange: this.onlyAHashChange(as)\n    });\n  }\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n  async prefetch(url, asPath, options) {\n    if (asPath === void 0) asPath = url;\n    if (options === void 0) options = {};\n    // Prefetch is not supported in development mode because it would trigger on-demand-entries\n    if (process.env.NODE_ENV !== \"production\") {\n      return;\n    }\n    if (typeof window !== \"undefined\" && (0, _isbot.isBot)(window.navigator.userAgent)) {\n      // No prefetches for bots that render the link since they are typically navigating\n      // links via the equivalent of a hard navigation and hence never utilize these\n      // prefetches.\n      return;\n    }\n    let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n    const urlPathname = parsed.pathname;\n    let {\n      pathname,\n      query\n    } = parsed;\n    const originalPathname = pathname;\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, this.locales).pathname;\n        parsed.pathname = pathname;\n        url = (0, _formaturl.formatWithValidation)(parsed);\n        let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n        const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n        parsedAs.pathname = localePathResult.pathname;\n        options.locale = localePathResult.detectedLocale || this.defaultLocale;\n        asPath = (0, _formaturl.formatWithValidation)(parsedAs);\n      }\n    }\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n    const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n    const isMiddlewareMatch = await matchesMiddleware({\n      asPath: asPath,\n      locale: locale,\n      router: this\n    });\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith(\"/\")) {\n      let rewrites;\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeloader.getClientBuildManifest)());\n      const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), this.locales);\n      if (rewritesResult.externalDest) {\n        return;\n      }\n      if (!isMiddlewareMatch) {\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n      }\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref;\n        parsed.pathname = pathname;\n        if (!isMiddlewareMatch) {\n          url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n      }\n    }\n    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n    if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n      pathname = parsed.pathname;\n      parsed.pathname = pathname;\n      Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n      if (!isMiddlewareMatch) {\n        url = (0, _formaturl.formatWithValidation)(parsed);\n      }\n    }\n    const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === \"strict\" ? null : await withMiddlewareEffects({\n      fetchData: () => fetchNextData({\n        dataHref: this.pageLoader.getDataHref({\n          href: (0, _formaturl.formatWithValidation)({\n            pathname: originalPathname,\n            query\n          }),\n          skipInterpolation: true,\n          asPath: resolvedAs,\n          locale\n        }),\n        hasMiddleware: true,\n        isServerRender: this.isSsr,\n        parseJSON: true,\n        inflightCache: this.sdc,\n        persistCache: !this.isPreview,\n        isPrefetch: true\n      }),\n      asPath: asPath,\n      locale: locale,\n      router: this\n    });\n    /**\n    * If there was a rewrite we apply the effects of the rewrite on the\n    * current parameters for the prefetch.\n    */\n    if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n      parsed.pathname = data.effect.resolvedHref;\n      pathname = data.effect.resolvedHref;\n      query = {\n        ...query,\n        ...data.effect.parsedAs.query\n      };\n      resolvedAs = data.effect.parsedAs.pathname;\n      url = (0, _formaturl.formatWithValidation)(parsed);\n    }\n    /**\n    * If there is a redirect to an external destination then we don't have\n    * to prefetch content as it will be unused.\n    */\n    if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n      return;\n    }\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n      this.components[urlPathname] = {\n        __appRouter: true\n      };\n    }\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? fetchNextData({\n        dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n          href: url,\n          asPath: resolvedAs,\n          locale: locale\n        }),\n        isServerRender: false,\n        parseJSON: true,\n        inflightCache: this.sdc,\n        persistCache: !this.isPreview,\n        isPrefetch: true,\n        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n      }).then(() => false).catch(() => false) : false;\n    }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n  }\n  async fetchComponent(route) {\n    const handleCancelled = getCancelledHandler({\n      route,\n      router: this\n    });\n    try {\n      const componentResult = await this.pageLoader.loadPage(route);\n      handleCancelled();\n      return componentResult;\n    } catch (err) {\n      handleCancelled();\n      throw err;\n    }\n  }\n  _getData(fn) {\n    let cancelled = false;\n    const cancel = () => {\n      cancelled = true;\n    };\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n      if (cancelled) {\n        const err = new Error(\"Loading initial props cancelled\");\n        err.cancelled = true;\n        throw err;\n      }\n      return data;\n    });\n  }\n  _getFlightData(dataHref) {\n    // Do not cache RSC flight response since it's not a static resource\n    return fetchNextData({\n      dataHref,\n      isServerRender: true,\n      parseJSON: false,\n      inflightCache: this.sdc,\n      persistCache: false,\n      isPrefetch: false\n    }).then(param => {\n      let {\n        text\n      } = param;\n      return {\n        data: text\n      };\n    });\n  }\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components[\"/_app\"];\n    const AppTree = this._wrapApp(App);\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n  get route() {\n    return this.state.route;\n  }\n  get pathname() {\n    return this.state.pathname;\n  }\n  get query() {\n    return this.state.query;\n  }\n  get asPath() {\n    return this.state.asPath;\n  }\n  get locale() {\n    return this.state.locale;\n  }\n  get isFallback() {\n    return this.state.isFallback;\n  }\n  get isPreview() {\n    return this.state.isPreview;\n  }\n  constructor(pathname, query, as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales,\n    isPreview\n  }) {\n    // Server Data Cache (full data requests)\n    this.sdc = {};\n    // Server Background Cache (HEAD requests)\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = createKey();\n    this.onPopState = e => {\n      const {\n        isFirstPopStateEvent\n      } = this;\n      this.isFirstPopStateEvent = false;\n      const state = e.state;\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n      if (!state.__N) {\n        return;\n      }\n      // Safari fires popstateevent when reopening the browser.\n      if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n        return;\n      }\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        key\n      } = state;\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._key !== key) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch (e) {}\n            // Restore old scroll position:\n            try {\n              const v = sessionStorage.getItem(\"__next_scroll_\" + key);\n              forcedScroll = JSON.parse(v);\n            } catch (e) {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n      this._key = key;\n      const {\n        pathname\n      } = (0, _parserelativeurl.parseRelativeUrl)(url);\n      // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n      if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n        return;\n      }\n      // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n      this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    };\n    // represents the current component key\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    // set up the component cache (by route keys)\n    this.components = {};\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n    if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n      const {\n        BloomFilter\n      } = require(\"../../lib/bloom-filter\");\n      const staticFilterData = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;\n      const dynamicFilterData = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;\n      if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n        this._bfl_s.import(staticFilterData);\n      }\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n        this._bfl_d.import(dynamicFilterData);\n      }\n    }\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp;\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);\n    }\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n    if (typeof window !== \"undefined\") {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        const asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale,\n          asPath\n        }).then(matches => {\n          options._shouldResolveHref = as !== pathname;\n          this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query\n          }), asPath, options);\n          return matches;\n        });\n      }\n      window.addEventListener(\"popstate\", this.onPopState);\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = \"manual\";\n        }\n      }\n    }\n  }\n}\nRouter.events = (0, _mitt.default)();","map":{"version":3,"names":["Object","defineProperty","exports","value","module","default","matchesMiddleware","createKey","_export","target","all","name","enumerable","get","Router","_interop_require_default","require","_interop_require_wildcard","_removetrailingslash","_routeloader","_script","_iserror","_","_denormalizepagepath","_normalizelocalepath","_mitt","_utils","_isdynamic","_parserelativeurl","_resolverewrites","_routematcher","_routeregex","_formaturl","_detectdomainlocale","_parsepath","_addlocale","_removelocale","_removebasepath","_addbasepath","_hasbasepath","_resolvehref","_isapiroute","_getnextpathnameinfo","_formatnextpathnameinfo","_comparestates","_islocalurl","_isbot","_omit","_interpolateas","_handlesmoothscroll","buildCancellationError","assign","Error","cancelled","options","matchers","Promise","resolve","router","pageLoader","getMiddleware","pathname","asPathname","parsePath","asPath","cleanedAs","hasBasePath","removeBasePath","asWithBasePathAndLocale","addBasePath","addLocale","locale","some","m","RegExp","regexp","test","stripOrigin","url","origin","getLocationOrigin","startsWith","substring","length","prepareUrlAs","as","resolvedHref","resolvedAs","resolveHref","hrefWasAbsolute","asWasAbsolute","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","removeTrailingSlash","denormalizePagePath","includes","page","isDynamicRoute","getRouteRegex","re","getMiddlewareData","source","response","nextConfig","basePath","i18n","locales","trailingSlash","Boolean","process","env","__NEXT_TRAILING_SLASH","rewriteHeader","headers","rewriteTarget","matchedPath","__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE","parsedRewriteTarget","parseRelativeUrl","pathnameInfo","getNextPathnameInfo","parseData","fsPathname","getPageList","getClientBuildManifest","then","param","__rewrites","rewrites","normalizeLocalePath","parsedSource","__NEXT_HAS_REWRITES","undefined","result","query","path","matchedPage","parsedAs","resolvedPathname","matches","getRouteMatcher","type","src","formatNextPathnameInfo","defaultLocale","buildId","destination","hash","redirectTarget","newAs","newUrl","withMiddlewareEffects","fetchData","data","effect","dataHref","json","text","cacheKey","e","manualScrollRestoration","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","fetch","credentials","method","ok","status","tryToParseAsJSON","JSON","parse","error","fetchNextData","inflightCache","isPrefetch","hasMiddleware","isServerRender","parseJSON","persistCache","isBackground","unstable_skipClientCache","href","URL","location","_params_method","getData","params","purpose","_tryToParseAsJSON","notFound","markAssetError","NODE_ENV","catch","err","message","Math","random","toString","slice","handleHardNavigation","getCancelledHandler","route","cancel","clc","handleCancelled","reload","back","forward","push","_key","stringify","x","self","pageXOffset","y","pageYOffset","change","replace","_bfl","skipNavigate","__NEXT_CLIENT_ROUTER_FILTER_ENABLED","matchesBflStatic","matchesBflDynamic","curAs","asNoSlash","asNoSlashLocale","_this__bfl_s","_this__bfl_s1","_bfl_s","contains","normalizedAS","curAsParts","split","i","_this__bfl_d","currentPart","join","_bfl_d","forcedScroll","_this_components_pathname","isLocalURL","isQueryUpdating","_h","shallow","shouldResolveHref","_shouldResolveHref","nextState","state","readyStateChange","isReady","isSsr","prevLocale","__NEXT_I18N_SUPPORT","localePathResult","detectedLocale","formatWithValidation","didNavigate","_this_locales","detectedDomain","detectDomainLocale","domainLocales","isLocaleDomain","hostname","domain","asNoBasePath","http","ST","performance","mark","scroll","routeProps","_inFlightRoute","events","emit","removeLocale","localeChange","onlyAHashChange","changeState","scrollToHash","set","components","parsed","urlIsNew","parsedAsPathname","__appRouter","isMiddlewareRewrite","isMiddlewareMatch","rewritesResult","p","externalDest","routeMatch","routeRegex","shouldInterpolate","interpolatedAs","interpolateAs","missingParams","keys","groups","filter","optional","console","warn","omit","isErrorRoute","_self___NEXT_DATA___props_pageProps","_self___NEXT_DATA___props","_routeInfo_props","routeInfo","getRouteInfo","isPreview","isFallback","cleanedParsedPathname","forEach","key","prefixedAs","rewriteAs","localeResult","curRouteMatch","component","Component","unstable_scriptLoader","scripts","concat","script","handleClientScriptLoad","props","__N_SSG","__N_SSP","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","notFoundRoute","fetchComponent","isNotFound","__NEXT_DATA__","statusCode","_routeInfo_route","isValidShallowRoute","_options_scroll","shouldScroll","resetScroll","upcomingScrollState","upcomingRouterState","_self___NEXT_DATA___props_pageProps1","_self___NEXT_DATA___props1","_routeInfo_props1","canSkipUpdating","compareRouterStates","document","documentElement","lang","hashRegex","getURL","_shallow","__N","handleRouteInfoError","loadErrorFail","isAssetError","styleSheets","getInitialProps","gipErr","routeInfoErr","requestedRoute","_data_effect","_data_effect1","_data_effect2","_data_response","existingInfo","cachedRouteInfo","fetchNextDataParams","getDataHref","skipInterpolation","sbc","sdc","resolvedRoute","isAPIRoute","res","mod","isValidElementType","wasBailedPrefetch","shouldFetchData","_getData","fetched","getProperError","sub","beforePopState","cb","_bps","oldUrlNoHash","oldHash","newUrlNoHash","newHash","handleSmoothScroll","scrollTo","rawHash","decodeURIComponent","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","onlyHashChange","prefetch","isBot","navigator","userAgent","urlPathname","originalPathname","__NEXT_MIDDLEWARE_PREFETCH","_isSsg","isSsg","priority","__NEXT_OPTIMISTIC_CLIENT_CACHE","componentResult","loadPage","fn","_getFlightData","ctx","App","AppTree","_wrapApp","loadGetInitialProps","constructor","initialProps","wrapApp","subscription","isFirstPopStateEvent","onPopState","__NA","getItem","initial","BloomFilter","staticFilterData","__NEXT_CLIENT_ROUTER_S_FILTER","dynamicFilterData","__NEXT_CLIENT_ROUTER_D_FILTER","numHashes","numItems","errorRate","import","autoExportDynamic","autoExport","__NEXT_ROUTER_BASEPATH","gssp","gip","isExperimentalCompile","appGip","gsp","search","_initialMatchesMiddlewarePromise","addEventListener","scrollRestoration"],"sources":["C:/Users/User/Documents/GitHub/e-billing/node_modules/next/dist/shared/lib/router/router.js"],"sourcesContent":["// tslint:disable:no-console\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    matchesMiddleware: null,\n    createKey: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    },\n    createKey: function() {\n        return createKey;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _removetrailingslash = require(\"./utils/remove-trailing-slash\");\nconst _routeloader = require(\"../../../client/route-loader\");\nconst _script = require(\"../../../client/script\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(require(\"../../../lib/is-error\"));\nconst _denormalizepagepath = require(\"../page-path/denormalize-page-path\");\nconst _normalizelocalepath = require(\"../i18n/normalize-locale-path\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(require(\"../mitt\"));\nconst _utils = require(\"../utils\");\nconst _isdynamic = require(\"./utils/is-dynamic\");\nconst _parserelativeurl = require(\"./utils/parse-relative-url\");\nconst _resolverewrites = /*#__PURE__*/ _interop_require_default._(require(\"./utils/resolve-rewrites\"));\nconst _routematcher = require(\"./utils/route-matcher\");\nconst _routeregex = require(\"./utils/route-regex\");\nconst _formaturl = require(\"./utils/format-url\");\nconst _detectdomainlocale = require(\"../../../client/detect-domain-locale\");\nconst _parsepath = require(\"./utils/parse-path\");\nconst _addlocale = require(\"../../../client/add-locale\");\nconst _removelocale = require(\"../../../client/remove-locale\");\nconst _removebasepath = require(\"../../../client/remove-base-path\");\nconst _addbasepath = require(\"../../../client/add-base-path\");\nconst _hasbasepath = require(\"../../../client/has-base-path\");\nconst _resolvehref = require(\"../../../client/resolve-href\");\nconst _isapiroute = require(\"../../../lib/is-api-route\");\nconst _getnextpathnameinfo = require(\"./utils/get-next-pathname-info\");\nconst _formatnextpathnameinfo = require(\"./utils/format-next-pathname-info\");\nconst _comparestates = require(\"./utils/compare-states\");\nconst _islocalurl = require(\"./utils/is-local-url\");\nconst _isbot = require(\"./utils/is-bot\");\nconst _omit = require(\"./utils/omit\");\nconst _interpolateas = require(\"./utils/interpolate-as\");\nconst _handlesmoothscroll = require(\"./utils/handle-smooth-scroll\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n    };\n    const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    const matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites }] = param;\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig: process.env.__NEXT_HAS_REWRITES ? undefined : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (process.env.__NEXT_HAS_REWRITES) {\n                    const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);\n                    if (result.matchedPage) {\n                        parsedRewriteTarget.pathname = result.parsedAs.pathname;\n                        as = parsedRewriteTarget.pathname;\n                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n                    }\n                } else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        });\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            });\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname + src.query + src.hash,\n                newUrl: \"\" + pathname + src.query + src.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    try {\n        const data = await options.fetchData();\n        const effect = await getMiddlewareData(data.dataHref, data.response, options);\n        return {\n            dataHref: data.dataHref,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            cacheKey: data.cacheKey,\n            effect\n        };\n    } catch (e) {\n        /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return null;\n    }\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== \"undefined\" && \"scrollRestoration\" in window.history && !!function() {\n    try {\n        let v = \"__next\";\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    var _params_method;\n    const getData = (params)=>fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref,\n                    response,\n                    text: \"\",\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || process.env.NODE_ENV !== \"production\" || data.response.headers.get(\"x-middleware-cache\") === \"no-cache\") {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (// chrome\n            err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url, router } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route, router } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options) {\n        if (options === void 0) options = {};\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch (e) {}\n            }\n        }\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"pushState\", url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options) {\n        if (options === void 0) options = {};\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"replaceState\", url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            for (const curAs of [\n                as,\n                resolvedAs\n            ]){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname)) {\n                        var _this__bfl_s, _this__bfl_s1;\n                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split(\"/\");\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                var _this__bfl_d;\n                                const currentPart = curAsParts.slice(0, i).join(\"/\");\n                                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        var _this_components_pathname;\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n            if (typeof options.locale === \"undefined\") {\n                options.locale = nextState.locale;\n            }\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n            const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n            if (localePathResult.detectedLocale) {\n                nextState.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                as = (0, _formaturl.formatWithValidation)(parsedAs);\n                url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n            }\n            let didNavigate = false;\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                var _this_locales;\n                // if the locale isn't configured hard navigate to show 404 page\n                if (!((_this_locales = this.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {\n                    parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);\n                    handleHardNavigation({\n                        url: (0, _formaturl.formatWithValidation)(parsedAs),\n                        router: this\n                    });\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale);\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                // if we are navigating to a domain locale ensure we redirect to the\n                // correct domain\n                if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    const asNoBasePath = (0, _removebasepath.removeBasePath)(as);\n                    handleHardNavigation({\n                        url: \"http\" + (detectedDomain.http ? \"\" : \"s\") + \"://\" + detectedDomain.domain + (0, _addbasepath.addBasePath)(\"\" + (nextState.locale === detectedDomain.defaultLocale ? \"\" : \"/\" + nextState.locale) + (asNoBasePath === \"/\" ? \"\" : asNoBasePath) || \"/\"),\n                        router: this\n                    });\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            if (didNavigate) {\n                return new Promise(()=>{});\n            }\n        }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark(\"routeChange\");\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit(\"hashChangeStart\", as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit(\"hashChangeComplete\", as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = \"replaceState\";\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== \"/_error\") {\n            options._shouldResolveHref = true;\n            if (process.env.__NEXT_HAS_REWRITES && as.startsWith(\"/\")) {\n                const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), this.locales);\n                if (rewritesResult.externalDest) {\n                    handleHardNavigation({\n                        url: as,\n                        router: this\n                    });\n                    return true;\n                }\n                if (!isMiddlewareMatch) {\n                    resolvedAs = rewritesResult.asPath;\n                }\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            } else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (process.env.NODE_ENV !== \"production\") {\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (process.env.NODE_ENV !== \"production\") {\n                        console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                    }\n                    throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit(\"routeChangeStart\", as, routeProps);\n        }\n        const isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n        try {\n            var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if (\"route\" in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                        const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, this.locales);\n                        nextState.locale = localeResult.detectedLocale || nextState.locale;\n                        rewriteAs = localeResult.pathname;\n                    }\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if (\"type\" in routeInfo) {\n                if (routeInfo.type === \"redirect-internal\") {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent(\"/404\");\n                        notFoundRoute = \"/404\";\n                    } catch (_) {\n                        notFoundRoute = \"/_error\";\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if (\"type\" in routeInfo) {\n                        throw new Error(\"Unexpected middleware effect on /404\");\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            var _routeInfo_route;\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n            var _options_scroll;\n            const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if (\"type\" in routeInfo) {\n                    throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n                }\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    if (nextState.locale) {\n                        document.documentElement.lang = nextState.locale;\n                    }\n                }\n                if (!isQueryUpdating) {\n                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options) {\n        if (options === void 0) options = {};\n        if (process.env.NODE_ENV !== \"production\") {\n            if (typeof window.history === \"undefined\") {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === \"undefined\") {\n                console.error(\"Warning: window.history.\" + method + \" is not available\");\n                return;\n            }\n        }\n        if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== \"pushState\" ? this._key : createKey()\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            \"\", as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        console.error(err);\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit(\"routeChangeError\", err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent(\"/_error\");\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(param) {\n        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            var _data_effect, _data_effect1, _data_effect2, _data_response;\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && process.env.NODE_ENV !== \"development\" ? existingInfo : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? \"/404\" : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                return data.effect;\n            }\n            if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\") {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (process.env.NODE_ENV !== \"production\") {\n                const { isValidElementType } = require(\"next/dist/compiled/react-is\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                }\n            }\n            const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                    {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== \"development\" && !isQueryUpdating) {\n                fetchNextData(Object.assign({}, fetchNextDataParams, {\n                    isBackground: true,\n                    persistCache: false,\n                    inflightCache: this.sbc\n                })).catch(()=>{});\n            }\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\", 2);\n        const [newUrlNoHash, newHash] = as.split(\"#\", 2);\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = \"\"] = as.split(\"#\", 2);\n        (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === \"\" || hash === \"top\") {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath, options) {\n        if (asPath === void 0) asPath = url;\n        if (options === void 0) options = {};\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (process.env.NODE_ENV !== \"production\") {\n            return;\n        }\n        if (typeof window !== \"undefined\" && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            if (options.locale === false) {\n                pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, this.locales).pathname;\n                parsed.pathname = pathname;\n                url = (0, _formaturl.formatWithValidation)(parsed);\n                let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n                const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n                parsedAs.pathname = localePathResult.pathname;\n                options.locale = localePathResult.detectedLocale || this.defaultLocale;\n                asPath = (0, _formaturl.formatWithValidation)(parsedAs);\n            }\n        }\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith(\"/\")) {\n            let rewrites;\n            ({ __rewrites: rewrites } = await (0, _routeloader.getClientBuildManifest)());\n            const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), this.locales);\n            if (rewritesResult.externalDest) {\n                return;\n            }\n            if (!isMiddlewareMatch) {\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n            }\n            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n            }\n        }\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === \"strict\" ? null : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: this.isSsr,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error(\"Loading initial props cancelled\");\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then((param)=>{\n            let { text } = param;\n            return {\n                data: text\n            };\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components[\"/_app\"];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._key !== key) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch (e) {}\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem(\"__next_scroll_\" + key);\n                            forcedScroll = JSON.parse(v);\n                        } catch (e) {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n            const { BloomFilter } = require(\"../../lib/bloom-filter\");\n            const staticFilterData = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;\n            const dynamicFilterData = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s.import(staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d.import(dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (typeof window !== \"undefined\") {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = \"manual\";\n                }\n            }\n        }\n    }\n}\nRouter.events = (0, _mitt.default)();\n\n//# sourceMappingURL=router.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}